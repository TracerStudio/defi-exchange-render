const express = require('express');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
const app = express();
const PORT = process.env.PORT || 3002;

// –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Å–ø–∏—Å–∫—É –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
function updateActiveUsers(userAddress) {
  try {
    const activeUsersFile = path.join(__dirname, 'database', 'active_users.json');
    let activeUsers = { users: [], lastUpdated: Date.now(), totalUsers: 0 };
    
    if (fs.existsSync(activeUsersFile)) {
      const data = fs.readFileSync(activeUsersFile, 'utf8');
      activeUsers = JSON.parse(data);
    }
    
    // –î–æ–¥–∞—î–º–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —è–∫—â–æ –π–æ–≥–æ —â–µ –Ω–µ–º–∞—î
    if (!activeUsers.users.includes(userAddress)) {
      activeUsers.users.push(userAddress);
      activeUsers.totalUsers = activeUsers.users.length;
      activeUsers.lastUpdated = Date.now();
      
      fs.writeFileSync(activeUsersFile, JSON.stringify(activeUsers, null, 2));
      console.log(`üë§ Added user to active users list: ${userAddress}`);
    }
  } catch (error) {
    console.error('‚ùå Error updating active users:', error);
  }
}

// Middleware –¥–ª—è CORS - –¥–æ–∑–≤–æ–ª—è—î–º–æ –≤—Å—ñ –¥–æ–º–µ–Ω–∏ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—ó–≤
app.use(cors({
  origin: function (origin, callback) {
    // –î–æ–∑–≤–æ–ª—è—î–º–æ –∑–∞–ø–∏—Ç–∏ –±–µ–∑ origin (–º–æ–±—ñ–ª—å–Ω—ñ –ø—Ä–∏—Å—Ç—Ä–æ—ó, Postman, —Ç–æ—â–æ)
    if (!origin) return callback(null, true);
    
    const allowedOrigins = [
      'http://localhost:3000', 
      'http://localhost:3001', 
      'http://localhost:3002',
      'http://91.196.34.246',
      'https://91.196.34.246',
      'http://144.31.189.82',
      'https://144.31.189.82',
      'http://id635272.com',
      'https://id635272.com',
      // –î–æ–¥–∞—î–º–æ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –¥–ª—è Vercel —Ç–∞ —ñ–Ω—à–∏—Ö —Ö–æ—Å—Ç–∏–Ω–≥—ñ–≤
      /^https:\/\/.*\.vercel\.app$/,
      /^https:\/\/.*\.netlify\.app$/,
      /^https:\/\/.*\.github\.io$/,
      // –î–æ–¥–∞—î–º–æ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—ó–≤
      /^https:\/\/.*\.onrender\.com$/,
      /^https:\/\/.*\.herokuapp\.com$/,
      // –î–æ–¥–∞—î–º–æ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –¥–ª—è Render
      /^https:\/\/.*\.onrender\.com$/
    ];
    
    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ origin –¥–æ–∑–≤–æ–ª–µ–Ω–∏–π
    const isAllowed = allowedOrigins.some(allowedOrigin => {
      if (typeof allowedOrigin === 'string') {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      }
      return false;
    });
    
    if (isAllowed) {
      console.log('‚úÖ CORS: Allowed origin:', origin);
      callback(null, true);
    } else {
      console.log('üîç CORS: Allowing origin (fallback):', origin);
      callback(null, true); // –î–æ–∑–≤–æ–ª—è—î–º–æ –≤—Å—ñ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—ó–≤
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin']
}));

// –î–æ–¥–∞—Ç–∫–æ–≤—ñ CORS –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –≤—Å—ñ—Ö –∑–∞–ø–∏—Ç—ñ–≤
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  
  // –î–æ–¥–∞—î–º–æ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –∫–µ—à—É–≤–∞–Ω–Ω—è –Ω–∞ –º–æ–±—ñ–ª—å–Ω–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—è—Ö
  res.header('Cache-Control', 'no-cache, no-store, must-revalidate');
  res.header('Pragma', 'no-cache');
  res.header('Expires', '0');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

// Middleware –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥—É JSON
app.use(express.json());

// –î–æ–¥–∞—Ç–∫–æ–≤—ñ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—ó–≤
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  
  // –î–æ–¥–∞—î–º–æ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –∫–µ—à—É–≤–∞–Ω–Ω—è –Ω–∞ –º–æ–±—ñ–ª—å–Ω–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—è—Ö
  res.header('Cache-Control', 'no-cache, no-store, must-revalidate');
  res.header('Pragma', 'no-cache');
  res.header('Expires', '0');
  
  next();
});

// Serve static files from the build directory
app.use(express.static(path.join(__dirname, 'build')));

// Serve the admin panel
app.get('/admin', (req, res) => {
  res.sendFile(path.join(__dirname, 'build', 'admin.html'));
});

// Serve the main app
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'build', 'index.html'));
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    service: 'DeFi Exchange Server',
    version: '1.0.0',
    endpoints: {
      main: '/',
      admin: '/admin',
      health: '/health',
      syncBalances: '/api/sync-balances',
      getBalances: '/api/balances/:userAddress',
      withdrawalRequest: '/withdrawal-request',
      withdrawalStatus: '/withdrawal-status/:requestId',
      testCors: '/test-cors',
      testBot: '/test-bot-connection'
    }
  });
});

// Test endpoint –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ CORS
app.get('/test-cors', (req, res) => {
  res.json({
    message: 'CORS test successful',
    origin: req.headers.origin,
    timestamp: new Date().toISOString()
  });
});

// Endpoint –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ Telegram –±–æ—Ç–∞
app.get('/test-bot-connection', async (req, res) => {
  try {
    const fetch = require('node-fetch');
    const botUrl = process.env.BOT_URL || 'http://127.0.0.1:3001';
    const botResponse = await fetch(`${botUrl}/health`, {
      method: 'GET',
      timeout: 5000
    });
    
    if (botResponse.ok) {
      const result = await botResponse.json();
      res.json({
        status: 'Bot connection OK',
        botResponse: result,
        timestamp: new Date().toISOString()
      });
    } else {
      res.status(500).json({
        status: 'Bot connection failed',
        error: 'Bot server not responding',
        timestamp: new Date().toISOString()
      });
    }
  } catch (error) {
    res.status(500).json({
      status: 'Bot connection error',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// API –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó –±–∞–ª–∞–Ω—Å—ñ–≤ –º—ñ–∂ –ø—Ä–∏—Å—Ç—Ä–æ—è–º–∏
app.post('/api/sync-balances', (req, res) => {
  try {
    const { userAddress, balances } = req.body;
    
    // –õ–æ–≥—É–≤–∞–Ω–Ω—è –¥–ª—è –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
    console.log('üì± Sync request from:', req.headers['user-agent']);
    console.log('üåê Origin:', req.headers.origin);
    console.log('üìä User Address:', userAddress);
    console.log('üí∞ Balances:', balances);
    
    if (!userAddress || !balances) {
      console.log('‚ùå Missing data:', { userAddress: !!userAddress, balances: !!balances });
      return res.status(400).json({ error: 'Missing userAddress or balances' });
    }
    
    // –°—Ç–≤–æ—Ä—é—î–º–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—é database —è–∫—â–æ –Ω–µ —ñ—Å–Ω—É—î
    const databaseDir = path.join(__dirname, 'database');
    if (!fs.existsSync(databaseDir)) {
      fs.mkdirSync(databaseDir, { recursive: true });
      console.log('üìÅ Created database directory');
    }
    
    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –±–∞–ª–∞–Ω—Å–∏ –≤ —Ñ–∞–π–ª
    const balancesFile = path.join(databaseDir, `user_balances_${userAddress}.json`);
    fs.writeFileSync(balancesFile, JSON.stringify(balances, null, 2));
    
    // –û–Ω–æ–≤–ª—é—î–º–æ —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
    updateActiveUsers(userAddress);
    
    console.log(`‚úÖ Synced balances for ${userAddress}:`, balances);
    res.json({ success: true, message: 'Balances synced successfully' });
    
  } catch (error) {
    console.error('‚ùå Error syncing balances:', error);
    res.status(500).json({ error: 'Failed to sync balances' });
  }
});

// API –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –±–∞–ª–∞–Ω—Å—ñ–≤ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
app.get('/api/balances/:userAddress', (req, res) => {
  try {
    const { userAddress } = req.params;
    
    // –õ–æ–≥—É–≤–∞–Ω–Ω—è –¥–ª—è –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
    console.log('üì± Get balances request from:', req.headers['user-agent']);
    console.log('üåê Origin:', req.headers.origin);
    console.log('üìä User Address:', userAddress);
    
    const balancesFile = path.join(__dirname, 'database', `user_balances_${userAddress}.json`);
    
    if (fs.existsSync(balancesFile)) {
      const balances = JSON.parse(fs.readFileSync(balancesFile, 'utf8'));
      console.log(`‚úÖ Found balances for ${userAddress}:`, balances);
      res.json({ success: true, balances });
    } else {
      console.log(`‚ùå No balances file found for ${userAddress}`);
      res.json({ success: true, balances: {} });
    }
    
  } catch (error) {
    console.error('‚ùå Error getting balances:', error);
    res.status(500).json({ error: 'Failed to get balances' });
  }
});

// API endpoint –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
app.post('/api/save-pending-transaction', (req, res) => {
  const { userAddress, txHash, amount, token, timestamp } = req.body;
  
  if (!userAddress || !txHash || !amount || !token) {
    return res.status(400).json({ 
      success: false, 
      error: 'Missing required fields' 
    });
  }
  
  try {
    const transactionsFile = path.join(__dirname, 'database', 'pending-transactions.json');
    
    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    if (!fs.existsSync(path.dirname(transactionsFile))) {
      fs.mkdirSync(path.dirname(transactionsFile), { recursive: true });
    }
    
    // –ß–∏—Ç–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ
    let allTransactions = {};
    if (fs.existsSync(transactionsFile)) {
      const data = fs.readFileSync(transactionsFile, 'utf8');
      allTransactions = JSON.parse(data);
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
    allTransactions[txHash] = {
      userAddress,
      amount,
      token,
      timestamp: timestamp || Date.now(),
      status: 'pending'
    };
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω–æ
    fs.writeFileSync(transactionsFile, JSON.stringify(allTransactions, null, 2));
    
    console.log(`‚úÖ Pending transaction saved: ${txHash} for ${userAddress}`);
    
    res.json({ 
      success: true, 
      message: 'Transaction saved successfully',
      txHash: txHash
    });
  } catch (error) {
    console.error('‚ùå Error saving pending transaction:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to save transaction' 
    });
  }
});

// API endpoint –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
app.get('/api/pending-transactions/:userAddress', (req, res) => {
  const { userAddress } = req.params;
  
  try {
    const transactionsFile = path.join(__dirname, 'database', 'pending-transactions.json');
    
    if (!fs.existsSync(transactionsFile)) {
      return res.json({ 
        success: true, 
        transactions: [] 
      });
    }
    
    const data = fs.readFileSync(transactionsFile, 'utf8');
    const allTransactions = JSON.parse(data);
    
    // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userTransactions = Object.entries(allTransactions)
      .filter(([txHash, tx]) => tx.userAddress === userAddress && tx.status === 'pending')
      .map(([txHash, tx]) => ({
        txHash,
        ...tx
      }));
    
    console.log(`üìã Found ${userTransactions.length} pending transactions for ${userAddress}`);
    
    res.json({ 
      success: true, 
      transactions: userTransactions 
    });
  } catch (error) {
    console.error('‚ùå Error getting pending transactions:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to get transactions' 
    });
  }
});

// API endpoint –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
app.delete('/api/remove-transaction/:txHash', (req, res) => {
  const { txHash } = req.params;
  
  try {
    const transactionsFile = path.join(__dirname, 'database', 'pending-transactions.json');
    
    if (!fs.existsSync(transactionsFile)) {
      return res.json({ 
        success: true, 
        message: 'No transactions file found' 
      });
    }
    
    const data = fs.readFileSync(transactionsFile, 'utf8');
    const allTransactions = JSON.parse(data);
    
    if (allTransactions[txHash]) {
      delete allTransactions[txHash];
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω–æ
      fs.writeFileSync(transactionsFile, JSON.stringify(allTransactions, null, 2));
      
      console.log(`üóëÔ∏è Removed transaction: ${txHash}`);
      
      res.json({ 
        success: true, 
        message: 'Transaction removed successfully' 
      });
    } else {
      res.json({ 
        success: true, 
        message: 'Transaction not found' 
      });
    }
  } catch (error) {
    console.error('‚ùå Error removing transaction:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to remove transaction' 
    });
  }
});

// –ü—Ä–æ–∫—Å—ñ –¥–ª—è –∑–∞—è–≤–æ–∫ –Ω–∞ –≤–∏–≤—ñ–¥ –¥–æ Telegram –±–æ—Ç–∞
app.post('/withdrawal-request', async (req, res) => {
  try {
    console.log('üîÑ Proxying withdrawal request to Telegram bot...');
    console.log('üìä Request data:', req.body);
    
    // –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è—î–º–æ –∑–∞–ø–∏—Ç –¥–æ Telegram –±–æ—Ç–∞
    const fetch = require('node-fetch');
    const botResponse = await fetch('http://127.0.0.1:3001/withdrawal-request', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(req.body)
    });
    
    const result = await botResponse.json();
    
    if (botResponse.ok) {
      console.log('‚úÖ Withdrawal request forwarded to bot successfully');
      res.json(result);
    } else {
      console.error('‚ùå Bot server error:', result);
      res.status(500).json({ error: 'Bot server error', details: result });
    }
    
  } catch (error) {
    console.error('‚ùå Error proxying withdrawal request:', error);
    res.status(500).json({ error: 'Failed to forward withdrawal request' });
  }
});

// –ü—Ä–æ–∫—Å—ñ –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å—É –∑–∞—è–≤–∫–∏
app.get('/withdrawal-status/:requestId', async (req, res) => {
  try {
    const { requestId } = req.params;
    console.log(`üîç Proxying status check for request: ${requestId}`);
    
    const fetch = require('node-fetch');
    const botResponse = await fetch(`http://127.0.0.1:3001/withdrawal-status/${requestId}`);
    const result = await botResponse.json();
    
    if (botResponse.ok) {
      console.log(`‚úÖ Status check successful for ${requestId}:`, result.status);
      res.json(result);
    } else {
      console.error(`‚ùå Bot server error for ${requestId}:`, result);
      res.status(500).json({ error: 'Bot server error', details: result });
    }
    
  } catch (error) {
    console.error(`‚ùå Error checking status for ${req.params.requestId}:`, error);
    res.status(500).json({ error: 'Failed to check withdrawal status' });
  }
});

// API –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π –≤ —ñ—Å—Ç–æ—Ä—ñ—é
app.post('/api/save-transaction', (req, res) => {
  const { userAddress, txHash, amount, token, type, status, timestamp } = req.body;
  
  if (!userAddress || !txHash || !amount || !token || !type || !status) {
    return res.status(400).json({ 
      success: false, 
      error: 'Missing required fields' 
    });
  }
  
  try {
    const transactionData = {
      userAddress,
      txHash,
      amount,
      token,
      type,
      status,
      timestamp: timestamp || Date.now()
    };
    
    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ —Ñ–∞–π–ª —ñ—Å—Ç–æ—Ä—ñ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π
    const historyFile = path.join(__dirname, 'database', `user_transactions_${userAddress}.json`);
    
    let transactions = [];
    if (fs.existsSync(historyFile)) {
      const data = fs.readFileSync(historyFile, 'utf8');
      transactions = JSON.parse(data);
    }
    
    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—è –≤–∂–µ —ñ—Å–Ω—É—î
    const existingIndex = transactions.findIndex(tx => tx.txHash === txHash);
    if (existingIndex !== -1) {
      // –û–Ω–æ–≤–ª—é—î–º–æ —ñ—Å–Ω—É—é—á—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é
      transactions[existingIndex] = transactionData;
      console.log(`üîÑ Updated transaction in history: ${txHash}`);
    } else {
      // –î–æ–¥–∞—î–º–æ –Ω–æ–≤—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é
      transactions.push(transactionData);
      console.log(`‚úÖ Added transaction to history: ${txHash}`);
    }
    
    fs.writeFileSync(historyFile, JSON.stringify(transactions, null, 2));
    
    // –û–Ω–æ–≤–ª—é—î–º–æ —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
    updateActiveUsers(userAddress);
    
    res.json({ 
      success: true, 
      message: 'Transaction saved to history',
      transaction: transactionData
    });
    
  } catch (error) {
    console.error('‚ùå Error saving transaction to history:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to save transaction to history' 
    });
  }
});

// API –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —ñ—Å—Ç–æ—Ä—ñ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
app.get('/api/user-transactions/:userAddress', (req, res) => {
  const { userAddress } = req.params;
  
  try {
    const historyFile = path.join(__dirname, 'database', `user_transactions_${userAddress}.json`);
    
    if (fs.existsSync(historyFile)) {
      const data = fs.readFileSync(historyFile, 'utf8');
      const transactions = JSON.parse(data);
      
      res.json({ 
        success: true, 
        transactions: transactions 
      });
    } else {
      res.json({ 
        success: true, 
        transactions: [] 
      });
    }
    
  } catch (error) {
    console.error('‚ùå Error loading user transactions:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to load user transactions' 
    });
  }
});

// API –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –∑–∞—è–≤–æ–∫ –Ω–∞ –≤–∏–≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
app.get('/api/withdrawal-requests/:userAddress', (req, res) => {
  const { userAddress } = req.params;
  
  try {
    const requestsFile = path.join(__dirname, 'database', `withdrawal_requests_${userAddress}.json`);
    
    if (fs.existsSync(requestsFile)) {
      const data = fs.readFileSync(requestsFile, 'utf8');
      const requests = JSON.parse(data);
      
      res.json({ 
        success: true, 
        requests: requests 
      });
    } else {
      res.json({ 
        success: true, 
        requests: [] 
      });
    }
    
  } catch (error) {
    console.error('‚ùå Error loading withdrawal requests:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to load withdrawal requests' 
    });
  }
});

// API –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–ø–∏—Å–∫—É –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
app.get('/api/active-users', (req, res) => {
  try {
    const activeUsersFile = path.join(__dirname, 'database', 'active_users.json');
    
    if (fs.existsSync(activeUsersFile)) {
      const data = fs.readFileSync(activeUsersFile, 'utf8');
      const activeUsers = JSON.parse(data);
      
      res.json({
        success: true,
        users: activeUsers.users,
        totalUsers: activeUsers.totalUsers,
        lastUpdated: activeUsers.lastUpdated
      });
    } else {
      res.json({
        success: true,
        users: [],
        totalUsers: 0,
        lastUpdated: Date.now()
      });
    }
    
  } catch (error) {
    console.error('‚ùå Error loading active users:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to load active users'
    });
  }
});

// API –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Å–ø–∏—Å–∫—É –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
app.post('/api/update-active-users', (req, res) => {
  try {
    const { userAddress } = req.body;
    
    if (!userAddress) {
      return res.status(400).json({
        success: false,
        error: 'User address is required'
      });
    }
    
    const activeUsersFile = path.join(__dirname, 'database', 'active_users.json');
    let activeUsers = { users: [], lastUpdated: Date.now(), totalUsers: 0 };
    
    if (fs.existsSync(activeUsersFile)) {
      const data = fs.readFileSync(activeUsersFile, 'utf8');
      activeUsers = JSON.parse(data);
    }
    
    // –î–æ–¥–∞—î–º–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —è–∫—â–æ –π–æ–≥–æ —â–µ –Ω–µ–º–∞—î
    if (!activeUsers.users.includes(userAddress)) {
      activeUsers.users.push(userAddress);
      activeUsers.totalUsers = activeUsers.users.length;
      activeUsers.lastUpdated = Date.now();
      
      fs.writeFileSync(activeUsersFile, JSON.stringify(activeUsers, null, 2));
      
      res.json({
        success: true,
        message: 'User added to active users list',
        totalUsers: activeUsers.totalUsers
      });
    } else {
      res.json({
        success: true,
        message: 'User already in active users list',
        totalUsers: activeUsers.totalUsers
      });
    }
    
  } catch (error) {
    console.error('‚ùå Error updating active users:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update active users'
    });
  }
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ DeFi Exchange Server running on port ${PORT}`);
  console.log(`üì± Main app: http://91.196.34.246:${PORT}`);
  console.log(`üîß Admin panel: http://91.196.34.246:${PORT}/admin`);
  console.log(`‚ù§Ô∏è  Health check: http://91.196.34.246:${PORT}/health`);
  console.log(`ü§ñ Telegram bot proxy: http://localhost:3001`);
});
